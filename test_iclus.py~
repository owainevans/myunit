from iclus import *

def testCopyFunction():
# test for copy_ripl funtion
    myv = make_church_prime_ripl()
    myv.assume('x','(beta 1 1)'); myv.observe('(normal x 1)','5'); myv.predict('(flip)')
    assert [build_exp(di['expression']) for di in myv.list_directives() ] ==  [build_exp(di['expression']) for di in copy_ripl(myv).list_directives() ]

def testParallelCopyFunction():
# test for parallel use of copy_ripl_string
## FIXME should be a try,except coz cluster won't be running
    cli = Client(); dv = cli[:]; dv.block=True
    dv.execute(copy_ripl_string)
    dv.execute('from venture.shortcuts import make_church_prime_ripl')
    dv.execute('v=make_church_prime_ripl()')
    dv.execute('v.set_seed(1)')
    dv.execute("v.assume('x','(beta 1 1)'); v.observe('(normal x 1)','5'); v.predict('(flip)')" )
    dv.execute("v2 = copy_ripl(v,seed=1)" )
    dv.execute("true_assert = [build_exp(di['expression']) for di in v.list_directives() ] ==  [build_exp(di['expression']) for di in copy_ripl(v).list_directives() ]")
    assert all(dv['true_assert'])



## TEST adding and removing ripls and pulling info about ripls to mripl

def testAddRemoveSize():
    no_rips = 4
    vv=MRipl(no_rips)

    def check_size(mr,no_rips):
        survey = mr.dview.apply(lambda: len(ripls))
        pred = mr.predict('(+ 1 1)')
        no_res = len(reduce(lambda s,t:s+t,pred))
        sizes = [mr.no_ripls, len(mr.seeds), len(mr.display_ripls()),
                len(mr.ripls_location), sum(survey), no_res]
        return sizes == ( [no_rips]*len(sizes) )

    assert(check_size(vv,no_rips))

    no_rips += 2
    vv.add_ripls(2)
    assert(check_size(vv,no_rips))

    no_rips -= 2
    vv.remove_ripls(2)
    assert(check_size(vv,no_rips))

def testCopyRipl():
    # create rips, add an assume. add some rips. get some reports
    # and see if reports are all the same. 
    no_rips = 4
    vv = MRipl(no_rips)
    vv.assume('x','3.')
    
    no_rips += 3
    vv.add_ripls(4)
    rep = vv.report(1)
    

def testDirectives():
    ## TEST DIRECTIVES
    v = MRipl(2); cat = lambda xs,ys: xs + ys 
    test_v = make_church_prime_ripl(); test_v.set_seed(0)
    ls_x = reduce(cat,v.assume('x','(uniform_continuous 0 1000)'))
    test_x = test_v.assume('x','(uniform_continuous 0 1000)')
    local_x = v.local_ripl.report(1)
    assert( np.round(test_x) in np.round(ls_x) )
    assert( np.round(local_x) in np.round(ls_x) )

    # # this fails with val = '-10.'
    v.observe('(normal x 50)','-10')
    test_v.observe('(normal x 50)','-10')
    ls_obs = v.report(2);
    ls_obs = reduce(cat,ls_obs)
    test_obs = test_v.report(2)
    local_obs = v.local_ripl.report(2)
    assert( ( [ np.round(test_obs)]*v.no_ripls ) == list(np.round(ls_obs))  )
    assert( ( [np.round(local_obs)]*v.no_ripls ) == list(np.round(ls_obs))  )

    v.infer(120); test_v.infer(120)
    ls_x2 = reduce(cat,v.report(1)); test_x2 = test_v.report(1);
    local_x2 = v.local_ripl.report(1)
    assert( np.round(test_x2) in np.round(ls_x2) )
    assert( np.round(local_x2) in np.round(ls_x2) )
    assert( np.mean(test_x2) < np.mean(test_x) )
    assert( not( v.no_ripls>10 and np.mean(test_x2) > 50) ) # may be too tight


    ls_x3=reduce(cat,v.predict('(normal x .1)')) 
    test_x3 = test_v.predict('(normal x .1)')
    local_x3 = v.local_ripl.predict('(normal x .1)')
    assert( np.round(test_x3) in np.round(ls_x3) )
    assert( np.round(local_x3) in np.round(ls_x3) )
    assert( np.mean(test_x3) < np.mean(test_x) )
    assert( not( v.no_ripls>10 and np.mean(test_x3) > 50) ) # may be too tight


tests = [testDirectives,testCopyRipl,testAddRemoveSize,testParallelCopyFunction,testCopyFunction]
